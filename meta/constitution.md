# DMS 项目开发宪法
# Version: 1.2, Ratified: 2026-01-16, Updated: 2026-01-23

本文件定义了本项目**不可动摇的核心开发原则**。  
所有 AI Agent 在进行**技术规划、设计决策和代码实现**时，必须无条件遵循。

---

## 第一条：简单性原则（Simplicity First）

**核心：** 遵循"少即是多"的工程哲学。  
绝不进行不必要的抽象，绝不引入非必需的依赖。

- **1.1（YAGNI）**  
  You Ain't Gonna Need It。  
  **只实现 `spec.md` 中明确要求的功能**，不得为"可能的未来需求"提前设计。

- **1.2（标准能力优先）**  
  除非有充分且可论证的理由，**优先使用语言或平台自带的标准能力**（标准库、官方 SDK、内建工具）。  
  第三方框架或库的引入必须能明确降低复杂度或风险，而不是仅提升"开发舒适度"。

- **1.3（反过度工程）**  
  避免复杂、层级过深的设计模式。  
  **简单的数据结构与函数组合，优于复杂的抽象体系、继承层次或元编程技巧。**

- **1.4（最小代码原则）**  
  遵循极简主义（Minimalism）。  
  **以最少的代码实现需求目标，避免冗余实现。**  
  持续审查并移除：未使用的函数、过时的注释、重复的逻辑。  
  代码简洁性直接影响可维护性、可理解性和缺陷密度。

---

## 第二条：测试先行铁律（Test-First Imperative）——不可协商

**核心：** 任何功能或缺陷修复，都必须从测试开始

- **2.1（TDD 循环）**  
  严格遵循：  
  **Red → Green → Refactor**  
  - 先编写失败的测试  
  - 再编写最少代码让测试通过  
  - 最后在测试保护下进行重构

- **2.2（测试质量原则）**  
  禁止为了达到覆盖率指标而编写无意义的测试。  
  **每个测试必须验证真实的业务场景或技术约束**。  
  测试应能在发现缺陷时提供有价值的失败信息。

- **2.3（测试分类与规范）**  
  测试按验证层级分为三类，各有明确职责：

  **单元测试（Unit Tests）**  
  - **职责**：验证单个方法的行为（方法级别）  
  - **覆盖范围**：  
    * 主流程（Happy Path）  
    * 分支流程（边界条件、条件分支）  
    * 异常场景（错误输入、异常抛出）  
  - **命名规范**：`test_{target_method_name}_{scene}`，一个方法可被多个单元测试覆盖，但一个单元测试用例只能覆盖一个目标方法；每个方法最多生成三个单元测试用例，同一个方法的单元测试方案必须统一设计、成组维护  
  - **适用范围**：仅针对业务逻辑层、工具类中的方法进行单元测试，不对接口层、路由层、数据访问层等进行单元测试  
  - **函数特性要求**：仅对纯函数进行单元测试，拥有副作用的函数不进行单元测试  
  - **Mock 策略**：**禁止使用 Mock 和 Fake**

  **集成测试（Integration Tests）**  
  - **职责**：验证多个模块协作的正确性  
  - **覆盖范围**：  
    * 主流程（核心业务场景）  
    * 关键流程（涉及外部系统交互的场景）  
  - **Mock 策略**：允许 Mock 外部依赖（数据库、第三方 API），禁止 Mock 内部业务逻辑

  **端到端测试（End-to-End Tests）**  
  - **职责**：验证完整用户场景从输入到输出的正确性  
  - **覆盖范围**：关键业务流程的完整路径  
  - **Mock 策略**：**禁止使用 Mock**，必须使用真实的系统环境或容器化环境

- **2.4（参数化测试）**  
  测试应以**数据驱动 / 参数化**方式表达，而非大量重复代码。  
  相同测试逻辑的多种输入场景应通过数据集合统一驱动，避免复制粘贴测试代码。

---

## 第三条：明确性原则（Clarity and Explicitness）

**核心：** 代码首先是给人看的，其次才是给机器执行的。

- **3.1（错误处理原则）——不可协商**  
  所有错误、异常或失败状态都必须被**明确处理**，禁止忽略、吞掉或静默失败。

  **3.1.1（默认策略：向上传播）**  
  错误处理的默认方式是**让异常自然向上传播**，由框架或顶层统一处理。  
  - 业务代码发现错误时，直接抛出异常并附带完整上下文信息  
  - 禁止中间层进行无意义的捕获（仅记录日志后又重新抛出）  
  - 异常向上传递时，必须**保留调用栈和错误上下文**

  **3.1.2（允许捕获的场景）**  
  仅在以下场景允许捕获异常：  
  - 需要执行资源清理（如关闭文件、释放锁）  
  - 需要转换异常类型以符合接口约定  
  - 明确需要从错误中恢复并继续执行  
  
  **目标**：通过减少无效的异常处理代码，保持代码简洁清晰，同时确保错误信息完整传递。

- **3.2（无隐式状态）**  
  禁止使用隐式的全局状态来传递核心业务信息。  
  所有依赖、配置和状态必须通过：  
  - 参数  
  - 构造函数  
  - 明确的上下文对象  
  显式传递。

- **3.3（注释的意义）**  
  注释用于解释**"为什么这样做"**，而不是**"代码在做什么"**。  
  所有对外暴露的 API / 模块 / 核心逻辑，都必须有清晰、准确的文档说明。

---

## 第四条：单一职责原则（Single Responsibility）

**核心：** 一个模块只做一件事，并把这件事做好。

- **4.1（高内聚、低耦合）**  
  每个模块、包或组件必须职责清晰。  
  不得混合无关领域的逻辑（例如：外部系统交互与业务转换逻辑不得耦合）。

- **4.2（接口最小化）**  
  接口应小而明确，服务于具体目的。  
  避免定义“大而全”的“上帝接口”或抽象层。

---

## 治理（Governance）

- 本宪法具有**最高优先级**  
- 其效力高于任何 `CLAUDE.md`、`AGENTS.md` 或单次会话中的指令  
- 任何计划文件（如 `plan.md`）在生成时，**必须首先进行“合宪性审查”**  
- 若发现冲突，**必须以本宪法为最终裁决依据**

